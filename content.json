{"pages":[],"posts":[{"title":"Guide for changing dev environment from Mac to Windows","text":"最近因为沉迷游戏，长期在游戏本上出生入死，手里那台用来聊天的 Mac 就晾在边上好久没掀开过了。想着手里几个小项目换电脑搞来搞去也挺麻烦的，所以决定在 windows 本上还原一下在 Mac 上的工作环境。 在 Mac 上或者远程服务器上，我们的开发、部署环境基本都是类 Unix 的，所以接下来我们需要把 WSL2 安装上，并且给系统安装一个不太拉胯的终端，以及配置 wsl 中系统的使用环境。 选择在 wsl 中开发，还有一个重要的原因，就是 windows 和 Unix 的换行符是不一样的，可能会带来一些编码方面的问题，比如 git 冲突。 安装 WSL微软把 WSL 叫做 适用于 Linux 的 Windows 子系统 ，我们只要知道这是一个跨操作系统的 linux 环境就好了，详细的说法还是看 wsl 的文档。从 windows 10 开始，系统提供了 WSL 集成，发展到现在的 windows 版本，已经有了 WSL 2 ，推荐升级到 WSL 2，现在能与系统更好的结合工作并且提供了完整的 Linux 内核，docker desktop 现在也与 WSL2 高度适配。 安装 WSL 2 需要满足 windows 10 的系统版本要求，X64 系统需要版本 1903 或更高版本，采用 内部版本 18362.1049 或更高版本。 为了避免一些麻烦，以下命令均在管理员身份的 PowerShell 中运行。 检查系统是否符合 WSL 2 运行要求先确定一下系统版本是否符合要求。 12# 回车运行后，会弹出一个窗口，只要显示的内部版本号大于上文所说的要求即可winver 如果系统版本不符合要求，请先升级到较新的版本再执行以下的操作。 启用 WSL如果系统符合要求，请接着往下。 12# 这条命令会开启系统的 wsl 功能，和你在控制面板里手动勾选是一样的dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用 虚拟化功能由于 WSL 2 需要虚拟化功能才可以运行，所以需要先启用 虚拟平台 功能。 12# 启用 `虚拟平台`dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 至此，先重启系统以完成 WSL 的安装并升级到 WSL 2。 更新 WSL 2 Linux 内核重启完成后，系统就已经把 WSL 安装好了，在切换到 WSL 2 之前，建议先更新系统的 WSL 2 Linux 内核，以免 WSL 切换到 WSL 2 时报错： 适用于 x64 计算机的 WSL2 Linux 内核更新包 将 WSL 2 设置为默认版本现在需要把 WSL 2 设置为默认的 WSL 版本： 1wsl --set-default-version 2 安装你喜欢的 Linux 发行版现在一切准备就绪，就差一个 Linux 了。到 Microsoft Store 找一个发行版安装。在搜索里输入 WSL 就会列出所有可用的 Linux 发行版，我安装的是 Ubuntu 20.04 LTS，所以 安装 WSL 这节之后的内容，不特指的话都是在 Ubuntu 20.04 LTS 中执行的。 安装好后，第一次启动，会开始初始化系统，并需要你为这个 Linux 创建用户和密码，这个密码就是以后你在 wsl 中输入 sudo 命令后，需要输入的密码。 WSL 进阶网络WSL 2 的网络不和 windows 直接互通。在 windows 中访问 WSL 2 里的服务，可以直接使用 http://localhost:8000 这种方式，但是 WSL 2 里就不能直接访问 windows 里的 web 服务了，新版本的 WSL 2 要拿 windows 的 IP 比较麻烦，目前网上的各种方法，几乎没作用。 文件互访在 WSL 2 里访问 windows 的目录和文件还是比较方便的。windows 的分区会全部挂载到 /mnt/ 下，比如要访问 D:\\，可以使用 cd /mnt/d。而在 windows 里，也可以直接在资源管理器的地址栏中输入 \\\\wsl$ 访问所有已经安装的 WSL。 而更加方便的是，可以直接在 WSL 的 shell 环境中直接执行 windows 中的程序，类似于 Mac 下的 open，例如： 123456# 使用 vs code 打开指定的目录或者文件code ./code ./main.js# 使用 Typora 打开当前目录或者文件typora.exe ./wsl.md 使用 Dockerdocker desktop 现在也已经针对 WSL 2做出了优化，可以直接安装 docker desktop。 Docker Desktop WSL 2 backend 一些遗憾 systemctl 启动选项无法使用，虽然可以借助第三方方法达成目的 WSL 2 一些可能会用到的命令使用 help 来了解全部可用的命令： 1wsl --help 如果要查看已经安装的 Linux 子系统所使用的 WSL 版本： 12# 列出已经安装的 linux 子系统，version 一列指的是 wsl 的版本wsl -l -v 子系统默认安装在 C:\\，如果你觉得占用的空间太多，需要迁移到别的位置，使用以下命令解决： 123456789101112131415161718192021222324# 停止 wsl 运行wsl --shutdown# 导出需要迁移的发行版，指定一个临时存放位置和文件名# wsl --export Ubuntu-20.04 d:\\temp\\wsl-Ubuntu-20.04.tarwsl --export &lt;Distro&gt; &lt;FileName&gt;# 注销需要迁移并且已经导出的发行版# wsl --unregister Ubuntu-20.04wsl --unregister &lt;Distro&gt;# 导入发行版# wsl --import Ubuntu-20.04 d:\\wsl\\Ubuntu-20.04 d:\\temp\\wsl-Ubuntu-20.04.tar --version 2wsl --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt; [--version &lt;WSL Version&gt;]# 运行迁移后的发行版# wsl --distribution Ubuntu-20.04wsl --distribution &lt;Distro&gt;# 此时，迁移后的系统使用的是 root 用户在运行，我们需要修改默认用户# Ubuntu2004 是刚刚导入的发行版去掉标点的名称# 可以在 `%LocalAppData%\\Microsoft\\WindowsApps` 找到。# username 是导出之前，你在子系统里使用的用户的用户名，密码也保持不变ubuntu2004 config --default-user &lt;username&gt; Hyper-V 动态端口占用过多的问题 如果有使用到 Hyper-V 的朋友，要提前考虑一下 windows 动态端口占用过多的问题。可以在安装 Hyper-V之前，先指定动态端口的范围，以避免端口占用过多，已经安装的程序或者项目跑不起来。 12345678910111213# 以管理员模式打开 powershell# 查看端口占用 interface/int# netsh interface ipv4 show tcp# 查看默认动态端口占用访问netsh int ipv4 show dynamicport tcp# 查看被占用端口是否在 hyper-v 预留的范围内netsh int ipv4 show excludedportrange protocol=tcp# 按需求指定动态端口范围netsh int ipv4 set dynamicport tcp start=49152 num=16384# 或者netsh int ip set dynamicport tcp start=49152 num=16384# 设置好后，重启电脑，Hyper-V 就会从 49152~65535 的范围内保留一部分端口。 适用于 Linux 的 Windows 子系统文档 安装 Terminal说到还原工作环境，写代码的应该不会只有我一个人是从终端开始的吧？ Mac 上习惯使用的终端是 iTerm2，刚好微软也搞了个评价不错的终端，还是个开源的，再也不用一直看着电脑上那个 cmd 和 powershell了。 安装 Windows Terminal 非常简单，打开 Microsoft Store，搜索 windows terminal，找到那个名字不带 preview 的，直接安装就行了。 有了 Windows Terminal 就有了一个好开端。运行 Windows Terminal 后，默认打开的可能是 PowerShell，在 PowerShell 中直接输入 bash 可以直接进入 wsl 的 shell 环境。 在顶部标签栏的右侧，有个下拉箭头，里面可以选择要打开的 shell 也可以对终端进行配置。如果你安装了新的 shell 环境或者新的 wsl 发行版，而终端没有找到，可以自己添加或者直接编辑配置文件。如果手动新增 shell 列表，可以需要填写 guid ，可以使用 GUID / UUID generator 生成一个。 另外，你可能对 Windows Terminal 深度配置或者美化感兴趣，也可以看看 Windows Terminal美化，优雅的办公带来超高的效率 。 最后，顺便推荐下微软的 PowerToys ，可以一定程度还原在 Mac 上空格预览、Alfread 等便利操作。 Shell我在 Mac 上使用的 shell 是 zsh，所以进入 WSL 后，随即就把 shell 切换为 zsh。 123456789101112# 查看系统中有哪些 shellcat /etc/shells# 如果没看到有 zsh，那就安装一个吧# 惯例，先把依赖什么的更新一遍sudo apt update &amp;&amp; sudo apt upgrade# 安装 zshsudo apt-get install zsh# 把 shell 切换为 zshchsh -s /bin/zsh# 重启 WSL 让 zsh 生效sudo reboot 切换为 zsh 后，为了让 zsh 更丝滑，接着安装 oh-my-zsh 1234# install oh-my-zsh via curl$ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"# install oh-my-zsh via wget$ sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" 最后，oh-my-zsh 的配置，从 Mac 上原样搬过来就可以用了。 特别的一点，如果要在 WSL 中打开 windows 的一些软件，每次都要输入 softwareName.exe 这样的一长串，非常烦。好在可以直接在 .zshrc 中设置别名来使用。 123export PATH=$PATH:'/mnt/c/Program Files/Typora'# aliasesalias typora=\"Typora.exe\" Package management在 Mac 上是我是用惯了 homebrew，所以我选择在 WSL 里也装上一份。 1/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 如果安装后发现 brew 命令不能正常使用，先确认当前 shell 的配置里是否有导出 homebrew 的路径。由于 homebrew 在 WSL 中的安装路由在 /home/linuxbrew/.linuxbrew ，但是这部分不会出现在 path 里，所以我们要先在 .profile 里导出： 12export BREW_HOME=\"/home/linuxbrew/.linuxbrew/bin\"export PATH=\"$PATH:$BREW_HOME\" 重载配置后应该能解决问题： 1source ~/.zshrc 解决方法来自这里：https://stackoverflow.com/questions/64680855/how-to-install-homebrew-on-windows-wsl-ubuntu-and-fix-zsh-brew-command-not-fo windows 上的包管理，其实还是有好几个的，不过之前都是第三方的包管理，现在微软自己弄了一 winget ，虽然上面的软件现在还不多，不过还是能满足我的需求的。 安装方法就不多说了，直接看官方文档 使用 winget 工具安装和管理应用程序 。 Source Code Editor &amp; Plugins因为我用的是 vs code 其他的 IDE 我也不清楚是什么情况，就不多说。 vs code 装好后，记得把 Remote - WSL 这个插件装上，它可以让你直接在宿主机上编辑 WSL 中的文件。 另外，强烈建议不要直接在 windows 里 git clone 任何远程项目，为了保持各方面的字符编码统一，请在 WSL 里 git clone 远程项目，新项目也建议你在 WSL 里建立。 What’s next?为了避免再继续写一些冗长无意义的内容，我决定就此打住。相信按上面的指引，应该可以帮助到避免一些从 Mac 转到 Windows 的麻烦，节省你的时间。 如果我在 WSL 上的工作环境有任何有意义的变化，我也会继续更新本文，以保证内容可以跟上变化。","link":"/Notes/guide-for-changing-dev-environment-from-mac-to-windows/"},{"title":"在 vue-element-admin 怎样动态生成路由配置？","text":"起因事情是这样的，项目里需要对路由和按钮配置权限，所以会涉及到动态输出路由的问题，然后前端用的是 vue-element-admin ，看项目里是支持动态加载的，但是官方文档里对这块说得…算是语焉不详吧。 然后我翻了翻 issue 挺多人在问的，也有不少人给出了解决方案。嗯，我权当整理一下，怕年纪大容易忘。 思路因为 vue-element-admin 主要是用于后台管理的框架，所以访问流程大致是这样子的： 发送登录请求 验证成功，返回 token 根据 token 返回当前用户信息，其中包括当前用户的角色，以及所属角色能访问的路由 前端创建一个路由组件映射表，主要作用是将后端返回的 component 的值替换为可执行的对象 将清洗过的路由表和前端存在的路由表合并 重载路由表，完成 其实核心在上面的第 4 条。根据项目 issue 里作者和其他人提供的方法，有两种映射表的创建方式： 前端创建创建一份静态的路由组件映射表 根据后端返回的路由表动态替换 我个人倾向于向后端录入一份路由表，然后再动态匹配。这样子只需要维护一份路由表，而不是一份路由表和一份路由组件映射表。 我目前在使用的 vue-element-admin 版本，可能和 issue 里大家讨论时的版本有比较大的差异，所以接下来的过程和代码，建立在 vue-element-admin version: 4.2.1 上。 准备工作：路由表的前端结构和数据库中数据结构路由表的前端结构先来看看框架的路由表长啥样。 123456789101112131415161718192021{ path: '/example', component: Layout, redirect: '/example/table', name: 'Example', meta: { title: 'Example', icon: 'example', roles: ['admin', 'editor'] }, children: [ { path: 'tree', name: 'Tree', component: () =&gt; import('@/views/tree/index'), meta: { title: 'Tree', icon: 'tree' } }, { path: 'form', name: 'Form', component: () =&gt; import('@/views/form/index'), meta: { title: 'Form', icon: 'form' } } ]} 这个就是一个拥有两个子菜单项的路由表。下面这个是另一种形式的。 12345678910111213{ path: '/icon', component: Layout, alwaysShow: true, children: [ { path: 'index', component: () =&gt; import('@/views/icons/index'), name: 'Icons', meta: { title: 'icons', icon: 'icon', noCache: true } } ]} 这是个只显示一个主菜单而没有子菜单项的路由表。当然，框架中并不只这两种方式，这只是我们需要的两种方式。 提示：再留意一下这两段数据中，都有个叫 component 的字段，表示的是，路由绑定的视图，这个应该都看得懂不用多作解释了。然后这里就是动态生成路由表的关键之处。我把这个字段的意思表示为 路由组件映射 。 component 的值，如果是从后端返回的，一定会是字符串，而且这时候，前端代码也已经由 webpack 打包好了，所以没办法起作用。那么就需要用映射表的方法，异步加载，让视图生效，从而实现动态加载路由需求。 路由表在数据库中的数据结构那么要把路由和权限结合起来，当然不能纯人工去维护，所以要在后端保存一份路由表，而且还指定了权限角色的。翻看了 vue-element-admin 的文档和代码，发现路由支持深度嵌套，而且父、子路由的结构是高度相似的，并没有做一个明显的区分，基于这个原因，父子的数据结构将是完全一致的，其中只有两个字段的赋值区别，下面再说。 鉴于此，以及框架支持路由深度嵌套，所以最后的菜单项，都可能是别的菜单的父或者子。这方面在这篇文不深入讨论。 因为我用的 mongodb ，我还是希望用比较平的结构来处理路由，下面是我的 schema 定义。 123456789101112131415161718192021222324252627282930313233343536373839404142const MenuSchema = new mongoose.Schema({ __v: { type: Number, select: false }, name: { type: String, required: true }, //设定路由的名字，一定要填写不然使用&lt;keep-alive&gt;时会出现各种问题 path: { type: String, required: true }, component: { type: String, default: 'Layout' }, redirect: { type: String, default: 'noRedirect' }, //重定向地址，在面包屑中点击会重定向去的地址 hidden: { type: Boolean, default: false }, // 不在侧边栏显示 // 当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面 // 只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面 // 若你想不管路由下面的 children 声明的个数都显示你的根路由 // 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由 alwaysShow: { type: Boolean, default: true }, //一直显示根路由 meta: { role: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Role', }], //设置该路由进入的权限，支持多个权限叠加。你可以在根路由设置权限，这样它下面所有的子路由都继承了这个权限 title: { type: String, required: true }, //设置该路由在侧边栏和面包屑中展示的名字 icon: { type: String }, //设置该路由的图标 noCache: { type: Boolean, default: false }, //如果设置为true，则不会被 &lt;keep-alive&gt; 缓存(默认 false) breadcrumb: { type: Boolean, default: true }, // 如果设置为false，则不会在breadcrumb面包屑中显示 }, children: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Menu', autopopulate: { maxDepth: 3 } }], extra: { type: mongoose.Schema.Types.Mixed }, createdAt: { type: Date, default: Date.now }}, { id: false, toObject: { virtuals: true }, toJSON: { virtuals: true }})MenuSchema.virtual('meta.roles', { ref: 'Role', localField: 'meta.role', foreignField: '_id', justOne: false, autopopulate: { select: 'name', maxDepth: 1 }})MenuSchema.plugin(require('mongoose-autopopulate')) 注意：这里要特别说明一下，因为这里的路由表是树状结构，最末尾的叶子，也就是最底层的 child 和 parent 中有两个字段的值是有区分的。一个是 alwaysShow，如果是叶子建议设置为 false ；另一个是redirect，在前端做数据清洗的时候，叶子中的这个值一定要设置为 fasle，alwaysShow 可以不设置，但是这项一定要设置。 到这里，前端后端的路由表结构就都清楚了。 还有一点顺带提一下，如果是一个显示时没有子菜单的菜单项，数据里，父项是不用设置 name 的. 建立路由组件映射表对于这个映射表，我们有两种常用的方法来解决。 由前端维护一份静态路由组件映射表这是交由前端来维护的一份与后端一样的组件映射表。 # src/router/index.js1234export const routerMap={ 'Tree': () =&gt; import('@/views/tree/index'), 'Form': () =&gt; import('@/views/form/index')} 面对这份路由组件映射表，实在是高兴不起来。既然后端已经保存有一份了，何苦再来手动维护一份映射表呢？所以还是写个方法，每次获得路由表的时候，都自动去匹配一次就好。所以也就有了下面这个动态替换的方法。 根据后端返回的路由表动态替换路由组件映射开发人员都是要想办法偷懒的，要不然不会有技术的进步。所以我们决定放弃手动维护一份映射表。 # src/store/modules/user.js12345678910111213141516171819202122232425262728293031323334353637383940/* Layout */import Layout from '@/layout'/** * 动态生成路由组件映射表并替换 * * @param {Array} serverRouterMap * @returns */function serverRouterMap(serverRouter) { const res = [] serverRouter.forEach(item =&gt; { const router = { ...item } if (router.component === 'Layout') { // Layout 要预先 import 进来 router.component = Layout } else { let views = router.component views = views.replace(/^\\/*/g, '') // 异步加载视图 // router.component = () =&gt; import(`@/views/${views}`) // 更新了某个版本的 webpack 后，只能用这种写法了 router.component = (resolve) =&gt; require([`@/views/${views}`], resolve) } if (router.children &amp;&amp; router.children.length &gt; 0) { router.children = serverRouterMap(router.children) } // 如果是最后的叶子节点，把 redirect 设置为 false if (router.redirect === 'noRedirect' &amp;&amp; router.children &amp;&amp; router.children.length === 0) { router.redirect = false } res.push(router) }) return res} 到这里，主要的方法就搞定了，接下来按登录的流程来生成动态路由。 生成动态路由要生成动态路由，还是要先拿到数据。在 src/store/modules/user.js 的 actions 里找到 getInfo方法，因为和当前用户相关的数据，都是从这里拿的。 # src/store/modules/user.js12345// 从返回的数据中拿到 routes 数据const { roles: role, username, avatar, routes } = data// 然后在合适的地方，调用 serverRouterMap() 方法，清洗并匹配路由组件映射后，重新赋值给 data.routesdata.routes = serverRouterMap(routes) 接下来，小小修改一下 generateRoutes() 方法。修改了接收的参数以及路由数据的来源，和你本地没修改过的方法，对照着改吧。 # src/store/modules/permission.js12345678910111213141516171819202122generateRoutes({ commit }, data) { return new Promise(resolve =&gt; { let accessedRoutes const { routes: serverAsyncRouterMap, roles } = data // generateRoutes 原来的写法 // if (roles.includes('admin')) { // accessedRoutes = asyncRoutes || [] // } else { // accessedRoutes = filterAsyncRoutes(asyncRoutes, roles) // } // 获取动态路由的写法 if (roles.includes('admin')) { accessedRoutes = serverAsyncRouterMap } else { accessedRoutes = filterAsyncRoutes(serverAsyncRouterMap, roles) } commit('SET_ROUTES', accessedRoutes) resolve(accessedRoutes) })} 接着就要 dispatch generateRoutes 来生成路由啦！ # src/permission.js123456789101112131415// get user info// 修改前的样子// note: roles must be a object array! such as: ['admin'] or ,['developer','editor']const { roles } = await store.dispatch('user/getInfo')// generate accessible routes map based on rolesconst accessRoutes = await store.dispatch('permission/generateRoutes', roles)// 修改后的样子// note: roles must be a object array! such as: ['admin'] or ,['developer','editor']const data = await store.dispatch('user/getInfo')// generate accessible routes map based on rolesconst accessRoutes = await store.dispatch('permission/generateRoutes', data) 到这里，就全部结束了。保存后，页面会自动刷新，你应该能看到最新的结果。 issue 中的相关讨论本文的思路来源于两个 issue 的讨论。 手动维护一份路由组件映射表 动态匹配路由组件映射表 最后，vue-element-admin 的项目地址。","link":"/Technology/Javascript/how-to-generate-dynamic-route-in-vue-element-admin-project/"},{"title":"Create video with Moviepy","text":"起因最近在学 scrapy 爬虫，顺手从微博上爬了张子枫和谭松韵的微博相片。然后就想，要不就顺手用爬的相片做个视频出来？ 需求＆思路我的思路是这样子的： 这个视频是 1080p 30fps； 我要给这个视频选一首好听的 BGM，然后每一幅相片都按 BGM 的节拍来显示； 视频长度和 BGM 长度匹配； 获取相片并将相片分辨率处理成和视频一样； 按节拍创建剪辑片段； 合并剪辑，生成视频 准备工作 由于我机器上使用的是 python 3 的环境，所以需要有 python 3。 建议在 python 的虚拟环境中运行这个项目。 在虚拟环境中安装 moviepy librosa click三个包。 如果要加字幕，还需要安装 imagemagick。 如果需要对字幕做分词处理，再安装一个 jieba。 我用的是 macbook，所有的命令都是在 macos 环境中执行。linux 的过程大同小异，windows 下需要自行搞定 python。 先分析一下最终的目录结构和文件 1234567891011.├── ./createVideoWithMoviepy.py # 这篇要讲的主要的东西├── ./dist│&nbsp;&nbsp; └── ./dist/1353112775.mp4 # 最后生成的视频，脚本会自动创建├── ./src│&nbsp;&nbsp; ├── ./src/font # 如果要加字幕，这里放字体│&nbsp;&nbsp; ├── ./src/images -&gt; ~/.../idols/images_origin # 资源源文件目录。这里是一个软链接，下文会解释│&nbsp;&nbsp; ├── ./src/imgs # 处理过的图片资源目录，脚本会自动创建│&nbsp;&nbsp; ├── ./src/music # BGM 目录│&nbsp;&nbsp; └── ./src/subtitles # 如果有字幕，字幕的纯文本文档放在这里└── ./utils.py # 一些工具脚本 假设 python3 环境已经存在。 12# 创建项目目录mkdir -p ./{moviepy/dist,moviepy/src/imgs,moviepy/src/music} 可有注意到，这里我没有创建moviepy/src/images这个目录？由于我爬取的相片在另外一个项目目录里idols/images_origin，所以这里将创建一个软链接来指向源目录。 1234# 进入 src 目录并观察创建软链接前后，目录里的变化cd moviepy/src &amp;&amp; llln -s ~/idols/images_origin imagesll 目录有了，接下来准备开发环境。 1234567891011# 先确保在项目根目录。约定：以下操作，均约定在我们的 moviepy 项目目录中进行。cd moviepy# 创建虚拟环境。由于我的系统中有 python2 和 python3。python3 -m venv venv# 激活虚拟环境. venv/bin/activate# 如果需要退出虚拟环境，使用下面的指令# deactivate 接下来，安装我们的依赖moviepy librosa click，另外，可能会需要处理图片，需要额外安装PIL。 123pip install moviepy librosa click# 额外安装 PILpip install pillow 最后，创建我们的两个脚本文件 1touch createVideoWithMoviepy.py utils.py 正式开始获取创建视频的一些参数:param width: 生成视频的宽度 default: 1920:param height: 生成视频的高度 default: 1080:param images_origin: 源图片的路径:param origin_target_dir: 将源路径替换为目标路径。 这个项目的源路径是爬虫下载图片的路径，最后还要把下载的图片处理成和视频一样的大小存放在目标目录 default: (‘./src/images’, ‘./src/imgs’):param music: 背景音乐路径:param fps: 视频的帧率 default: 30:param output: 生成视频的文件名 如此，我们先来定义要获取的参数。这里用到了Click，它以简单的交互方式，帮助我在命令行模式下获取需要的参数值。 # createVideoWithMoviepy.py @python31234567891011# -*- coding: utf-8 -*-import click@click.command()@click.option('--width', prompt='Width', default=1920, help='The width of video clips')@click.option('--height', prompt='Height', default=1080, help='The height of video clips')@click.option('--images_origin', prompt='images file', default='./src/images', help='The source images path')@click.option('--origin_target_dir', prompt='replace origin dir to target dir', default=('./src/images', './src/imgs'), help='how replace origin dir to target dir')@click.option('--music', prompt='Music file', default='./src/music/1302.mp3', help='The music file')@click.option('--fps', prompt='video fps ', default=30, help='The output video fps')@click.option('--output', prompt='Output file', default='./dist/1353112775.mp4', help='The output file name') 获取相片并调整相片大小# createVideoWithMoviepy.py @python3123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始加载库&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')import osimport mathimport click# 导入两个工具函数来处理图片，这里不展开说明，具体看源码from utils import resizeImage, readDirdef main(width, height, images_origin, origin_target_dir, music, fps, output): # 从源目录读取且经处理过的图片，将会保存到这个目录中，为了方便处理，这里尽量和源目录的结构保持一致 target_images_dir = images_origin.replace(origin_target_dir[0], origin_target_dir[-1]) # 如果目标目录不存在，则从源目录读取图片并进行处理，最后保存到目标目录 if not os.path.exists(target_images_dir): filesPath = readDir(images_origin) print('&gt;&gt;已载入文件 %s 个' % len(filesPath)) print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始调整图片大小&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;') for img in filesPath: resizeImage(img, origin_target_dir, (width, height)) # 从目标目录中读取图片路径到一个列表里 print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始读取调整过的图片&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;') filesPath = readDir(images_origin.replace(origin_target_dir[0], origin_target_dir[-1])) print('&gt;&gt;已载入文件 %s 个' % len(filesPath)) # 如果文件列表长度为 0，则退出整个程序 if len(filesPath) == 0: print('&gt;&gt;请检查源目录 %s 下是否有图片。并且删除 %s 目录' % (images_origin, origin_target_dir[-1])) os._exit(0) 使用 librosa 分析 BGM 的节拍# createVideoWithMoviepy.py @python31234567import librosa print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始分析节拍&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;') y, sr = librosa.load(music, sr=None) tempo, beats = librosa.beat.beat_track(y=y, sr=sr) beat_times = list(librosa.frames_to_time(beats, sr=sr)) beat_times.append(beat_times[-1] + 1) # 增加一个空节拍点位，先记着有这么一回事，下面会讲 创建视频剪辑（Clip）前的一些小准备先简单说一下视频/动画的小原理，我们看到的每一秒画面，一般都是由很多帧组成的。在这个项目里，一秒画面有 30 帧（30fps）。而一个动作的连续画面，至少要有头尾两个动作关键帧。但是现在只有单幅的相片，表现不出一个完整的动作，所以我们最终的成品会是一个幻灯片。😅 到这里就大概清楚了，如果要让一幅照片播放一秒，那就需要在这一秒里插入 30 帧。因为是单幅，所以这 30 帧就是这幅照片重复 30 次。 项目要求我们按照节拍来显示相片，但是两个节拍之间的间隔可能不到一秒，所以相片的帧数可能有多有少，不一定是 30 帧。 而且一秒的画面停留时间太短，也就是一闪而过的效果，根本看不清，那怎么办呢？ #createVideoWithMoviepy.py @python31234567891011clips = [] # 创建一个空的 list，用来存放所有的剪辑audio_time = librosa.get_duration(filename=music)print('&gt;&gt;音频时长(s):%f &gt;&gt;节拍数量：%s' % (audio_time, len(beat_times)))'''计算节拍数量和相片数量的差值比例，以计算需要在每幅相片后补足多少帧，这里计算的差值，是为了让相片能补足节拍的数量，多跨几个节拍，让每一幅相片停留更长时间。另外，这个算法有 bug，下面再说。'''interval = math.ceil(abs( len(beat_times) / len(filesPath) ))filesPath = [f for f in filesPath for i in range( interval )]print('&gt;&gt;新的文件列表长度:%s' % len(filesPath)) 按节拍插入帧# createVideoWithMoviepy.py @python31234567891011121314151617181920212223print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始按节拍生成视频帧&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')for index, beat_time in enumerate(beat_times[:-1]): if index &gt;= len( filesPath): print('&gt;&gt;图片数量不足以匹配节拍，中止匹配。输出的视频后段可能会出现黑屏。') print('&gt;&gt;图片数量：{0} &gt;节拍数量：{1}'.format(len( filesPath), len(beat_times))) break print(f'{index + 1}/{len(beat_times)}&gt;&gt;{ filesPath[index]}') ''' 说下 time_deff 的作用： 因为每个节拍间的间隔时间非常短，所以计算节拍间的间隔再乘以帧率， 得出这幅画面在这个节拍应该停留的时间 '''` time_diff = math.modf(beat_time - beat_times[index -1]) time_diff = math.ceil(time_diff[0]*10) if (time_diff[0] * 10) &gt; time_diff[-1] else math.ceil(time_diff[-1]) image_clip = (ImageClip(filesPath[index], duration=abs(time_diff)*fps) .set_fps(abs(time_diff)*fps) .set_start(beat_time) .set_end(beat_times[index + 1])) #还记得上面增加的那个空节拍点位么？需要给最后一帧一个结束时间，所以这里增加了一个空点位来处理 image_clip = image_clip.set_pos('center') # 两幅不同的相片间的过渡方式，duration 的值可以随意更改，不过可能会增加视频压制的时间 if index % interval == 0: image_clip = image_clip.fx(vfx.fadein, duration=0.5) clips.append(image_clip) 合并剪辑，生成视频终于到最后一步了！ # createVideoWithMoviepy.py1234567891011121314print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始合并剪辑，生成视频&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')final_clip = CompositeVideoClip(clips) # 合并所有视频剪辑audio_clip = AudioFileClip(music) # 创建一个音频剪辑final_video = final_clip.set_audio(audio_clip) # 加入音频剪辑# 最后写入视频文件，moviepy 会调用 ffmpeg 来压制最后的视频，没有这个包，也得装上final_video.write_videofile( output, # 输出路径和文件名 fps=fps, # 帧率 codec='mpeg4', # 视频编码 # ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo preset='medium', # 压缩速度 audio_codec=\"libmp3lame\", # 音频编码，适用 .mp3 threads=4, # 压缩线程 bitrate ='6000k') # 视频比特率，1080p 30fps 的动态比特率是 4000k~6000k 一个问题还记得上面提到的那个 bug 吗？这里面有一些问题，如果图片数量多于节拍数？如果补齐节拍数量后的图片 list length 多于节拍数？如何确定匹配 bgm 节拍的最佳图片数量和帧率？ 总结这个脚本问题还是挺多的，但是完成了我最初的要求。唯一不满意的就是这是一个加了 BGM 的幻灯片，我下次还是爬视频吧。 moviepy 做逐帧动画不是强项，效率低于 opencv，但是如果想要批量修改一些比较相似的视频剪辑，还是可以用的。这货有一个大缺点，就是太费内存了，文档也不够友好。但是，好用就够了。 librosa 这个库也很强大，能够各种分析音频，对声音领域有要求的小伙伴可以试试。 大家关心的源码，Create video with Moviepy","link":"/Technology/Python/create-video-with-moviepy/"},{"title":"MirageJS Quickstarts Part 1 - Overview","text":"最近在项目中使用了 Mirage ,看着官方文档，做了一些笔记。文中的内容都来自于官方文档，包括例子，并不是完整翻译了官方文档，结合自己的使用体会做了增删，就是翻译了又没完全翻译。 简介Mirage 是一个让前端开发人员模拟后端 API 的 JavaScript 库。用人话说就是：Mirage 是一个 Mock 服务器。 Mirage 在浏览器中运行。它能拦截 Javascript 应用程序发出的任何 XMLHttpRequest 或 fetch 请求，并允许模拟这些请求所对应的响应结果。 Mirage 除了拦截 HTTP 请求外，还提供了一个模拟数据库和一系列辅助函数，可以轻松模拟后端服务。 Mirage 借鉴了典型的 API 服务端框架的概念，拥有例如： 处理 HTTP 请求的路由（routes） 数据库（database）和数据模型（models），用于存储数据和定义数据之间的关系 factories(模型工厂) and fixtures for stubbing data(数据填充) 用于格式化 HTTP 响应的序列化函数（serializers） 安装Mirage 很容易可以集成到现有项目中。 123npm install --save-dev miragejs# oryarn add --dev miragejs 概览Mirage 可以通过 路由处理器（route handlers）轻易的模拟一个 API 请求的响应结果。 静态路由（Static Route Handlers）123456789101112131415161718import { createServer } from \"miragejs\"createServer({ routes() { this.namespace = 'api' // in app makes a GET request to `/api/movies`, Mirage will respond with this data. this.get('/movies', () =&gt; { return { movies: [ { id: 1, name: 'Inception', year: 2010}, { id: 1, name: 'Interstellar', year: 2014}, { id: 1, name: 'Dunkirk', year: 2017}, ], } }) }}) 可以像上面这个示例中一样，使用静态路由来完成对 API 返回的模拟。路由处理器支持所有的 HTTP 动词（get/post/delete/put …）。 也可以在路由的第三个参数中使用 timing 选项来模拟服务器延迟。 123456789101112...// Using the `timing` option to slow down the responsethis.get( '/movies', () =&gt; { return { movies: [], } }, { timing: 4000 })... 也可以在路由中定义如何从 API 中获取需要的请求参数。 123456789...// Responding to a POST requestthis.post(\"/movies\", (schema, request) =&gt; { let attrs = JSON.parse(request.requestBody) attrs.id = Math.floor(Math.random() * 100) return { movie: attrs }})... 也可以返回一个 HTTP Error。 123456789...// Using the `Response` class to return a 500this.delete(\"/movies/1\", () =&gt; { let headers = {} let data = { errors: [\"Server did not respond\"] } return new Response(500, headers, data)})... 动态路由（Dynamic Route Handlers）静态路由已经可以很好的工作了。但是静态路由不能总是满足我们花样请求数据的需求，比如按条件筛选查询结果时，静态路由就不能很好的满足需求。我们需要一个能模拟真实查询数据库时那种方式，让我们在路由之前先引入数据模型。 123456789101112131415import { createServer, Model } from \"miragejs\"createServer({ // 引入并定义数据模型 models: { movie: Model, }, routes() { this.namespace = 'api' // schema 参数可以访问到 model 中的数据 this.get('/movies', (schema, request) =&gt; { return schema.movies.all() }) }}) 如果现在请求 GET /api/movies ，将返回一个空数组，因为我们还没给定义好的模型填充数据。 1234// GET /api/movies{ \"movies\": []} 现在让我们来给模型填充数据。 123456789createServer({ models: {}, routes() {}, seeds(server) { server.create(\"movie\", { name: \"Inception\", year: 2010 }) server.create(\"movie\", { name: \"Interstellar\", year: 2014 }) server.create(\"movie\", { name: \"Dunkirk\", year: 2017 }) },}) server.create() 方法将向数据库中插入一条数据（Mirage 会在内存中运行一个数据库），第一个参数是模型的名称，第二个参数是要插入的数据。在实际开发中，可以模型工厂里，配合 Marak/faker.js 等库插入大量的假数据用于测试。 现在再请求 GET /api/movies ,将会返回一个结果： 123456789// GET /api/movies{ \"movies\": [ { \"id\": 1, \"name\": \"Inception\", \"year\": 2010 }, { \"id\": 2, \"name\": \"Interstellar\", \"year\": 2014 }, { \"id\": 3, \"name\": \"Dunkirk\", \"year\": 2017 } ]} 既然是动态路由，那应该做一些动态路由应该作的事情。下面的例子使用标准的 RESTful 路由模式来返回 Movie 资源： 1234567891011121314151617181920212223242526272829this.get(\"/movies\", (schema, request) =&gt; { return schema.movies.all()})this.get(\"/movies/:id\", (schema, request) =&gt; { let id = request.params.id return schema.movies.find(id)})this.post(\"/movies\", (schema, request) =&gt; { let attrs = JSON.parse(request.requestBody) return schema.movies.create(attrs)})this.patch(\"/movies/:id\", (schema, request) =&gt; { let newAttrs = JSON.parse(request.requestBody) let id = request.params.id let movie = schema.movies.find(id) return movie.update(newAttrs)})this.delete(\"/movies/:id\", (schema, request) =&gt; { let id = request.params.id return schema.movies.find(id).destroy()}) 路由缩写（Shorthands）使用缩写可以减少代码的冗余，也可以让路由定义更简洁。在默认的情况下，动态路由一节里， RESTful 请求返回的示例中的所有路由定义，都可以使用缩写的方式来完成，路由缩写与上面例子中定义的同名路由完成一样的工作： 12345this.get(\"/movies\")this.get(\"/movies/:id\")this.post(\"/movies\")this.patch(\"/movies/:id\")this.del(\"/movies/:id\") 非常建议始终使用路由缩写来定义路由，除非你需要在路由定义里完成额外的工作。 模型工厂（Factories）模型工厂是一个可以为指定模型生成逼真种子数据的对象，最终将用生成的种子数据填充到模型中。 123456789101112131415161718192021222324import { createServer, Model, Factory } from \"miragejs\"createServer({ models: { movie: Model, }, factories: { movie: Factory.extend({ title(i) { return `Movie ${i}` // Movie 1, Movie 2, etc. }, year() { let min = 1950 let max = 2019 return Math.floor(Math.random() * (max - min + 1)) + min }, rating: \"PG-13\", }), },}) 现在使用 server.create API来为 movie 模型创建数据，Mirage 将会使用定义好的模型工厂来生成默认的数据。 123456789101112131415161718192021222324252627282930313233server.create(\"movie\")server.create(\"movie\")// 可以使用自定义的数据替换生成的数据中指定的属性的值server.create(\"movie\", { rating: \"R\" })server.db.dump()/* Mirage's database now contains { movies: [ { id: 1, title: \"Movie 1\", year: 1992, rating: \"PG-13\", }, { id: 2, title: \"Movie 2\", year: 2008, rating: \"PG-13\", }, { id: 3, title: \"Movie 3\", year: 1947, rating: \"R\", } ] }*/ 使用 server.createList API 来批量生成数据，可以在 seeds() 方法中同时使用 server.create 和 server.createList API。 1234567import { createServer, Factory } from \"miragejs\"createServer({ seeds(server) { server.createList(\"movie\", 10) },}) 在编写单元测试时（测试环境），Mirage 会载入路由定义，但会忽略为路由生成的种子数据，但是勿需担心，你可以在开始测试之前为 Mirage 路由生成数据。 1234567891011121314151617181920212223242526// app-test.jsimport React from \"react\"import { render, waitForElement } from \"@testing-library/react\"import App from \"./App\"import startMirage from \"./start-mirage\"let serverbeforeEach(() =&gt; { server = startMirage({ environment: \"test\" })})afterEach(() =&gt; { server.shutdown()})it(\"shows the list of movies\", async () =&gt; { // 生成测试数据 server.createList(\"movie\", 5) const { getByTestId } = render(&lt;App /&gt;) await waitForElement(() =&gt; getByTestId(\"movie-list\")) expect(getByTestId(\"movie-item\")).toHaveLength(5)}) 数据关系（Relationships）Mirage 提供了 ORM 来处理数据关系。继续上面的例子，一部影片可以有多个演员，所以来定义一个一对多的关系： 123456789101112131415161718192021222324import { createServer, hasMany, belongsTo } from \"miragejs\"createServer({ models: { movie: Model.extend({ castMembers: hasMany(), }), castMember: Model.extend({ movie: belongsTo(), }), }, seeds(server) { server.create('movie', { name: \"Interstellar\", year: 2014, castMembers: [ server.create(\"cast-member\", { name: \"Matthew McConaughey\" }), server.create(\"cast-member\", { name: \"Anne Hathaway\" }), server.create(\"cast-member\", { name: \"Jessica Chastain\" }), ], }) },}) 我们定义了两个模型 movie 和 castMember ，并且定义了两个模型之间的关系。现在就可以在路由定义中查询出关联的数据了： 12345this.get('/movie/:id/cast-menbers', (schema, request) =&gt; { let movie = schema.movies.find(request.params.id) return movie.castMembers}) Mirage 会自动使用外键来维护两个模型间的关系，所以不需要担心数据会混乱。 响应数据序列化（Serializers）Mirage 默认返回的响应数据是这样子的： 123456789// GET /api/movies{ \"movies\": [ { \"id\": 1, \"name\": \"Inception\", \"year\": 2010 }, { \"id\": 2, \"name\": \"Interstellar\", \"year\": 2014 }, { \"id\": 3, \"name\": \"Dunkirk\", \"year\": 2017 } ]} 也许你的产品使用的是 JSON:API spec ，所以响应的数据看起来像这样子： 123456789101112131415161718192021// GET /api/movies{ \"data\": [ { \"id\": 1, \"type\": \"movies\", \"attributes\": { \"name\": \"Inception\", \"year\": 2010 } }, { \"id\": 2, \"type\": \"movies\", \"attributes\": { \"name\": \"Interstellar\", \"year\": 2014 } }, { \"id\": 3, \"type\": \"movies\", \"attributes\": { \"name\": \"Dunkirk\", \"year\": 2017 } } ]} Mirage 的设计初衷是为了完整重现你的产品的 API 服务。借助 Mirage 提供的数据序列化（Serializers）能力，可以自定义格式化响应数据。 Mirage 提供了几个与流行的后端数据响应格式匹配的命名序列化方法： 1234567import { createServer, JSONAPISerializer } from \"miragejs\"createServer({ serializers: { application: JSONAPISerializer, }}) 例子中只演示了 JSONAPISerializer ，实际还有 ActiveModelSerializer 和 RestSerializer ，将在后面的章节作详细的说明。 如果 Mirage 提供的序列化不能满足需求，可以基于 Serializer 基类扩展自己的数据格式： 1234567891011121314import { createServer, Serializer } from \"miragejs\"createServer({ serializers: { application: Serializer.extend({ keyForAttribute(attr) { return dasherize(attr) }, keyForRelationship(attr) { return dasherize(attr) }, }), },}) Mirage 的序列化层知道模型间的关系，这有利于模拟数据侧载或者嵌套关系数据： 1234567891011createServer({ serializers: { movie: Serializer.extend({ include: [\"crewMembers\"], }), }, routes() { this.get(\"/movies/:id\") },}) 响应数据中将自动包含关系数据 crew-members： 12345678910111213141516171819202122232425// GET /movies/1{ \"movie\": { \"id\": 1, \"title\": \"Interstellar\" }, \"crew-members\": [ { \"id\": 1, \"movie-id\": 1, \"name\": \"Matthew McConaughey\" }, { \"id\": 2, \"movie-id\": 1, \"name\": \"Anne Hathaway\" }, { \"id\": 3, \"movie-id\": 1, \"name\": \"Jessica Chastain\" } ]} Mirage 提供的命名序列化方法完成了大量诸如此类的定义工作，因此应该将它们用作最终的数据序列化方法，并且仅在不能满足需求时才添加特定的 API 自定义项。 放行（Passthrough）默认情况下，如果你的应用发出的请求未定义相应的 Mock 路由请求，Mirage 将会抛出一个错误。 假如你现在的应用正在使用 Mirage 或者不想使用 Mirage 模拟所有的 API，为避免因未定义的路由而抛出错误，使用 passthrough() 方法放行未定义的请求： 123456createServer({ routes() { // Allow unhandled requests on the current domain to pass through this.passthrough() },}) 当需要为现有的应用开发新的功能，不需要等待后端的 API 更新，使用 Mirage 就可以模拟新的 API 并且放行已经在生产环境中使用的 API ： 1234567891011121314createServer({ routes() { // Mock this route and Mirage will intercept it this.get(\"/movies\") // All other API requests on the current domain will still pass through // e.g. GET /api/directors this.passthrough() // If your API requests go to an external domain, pass those through by // specifying the fully qualified domain name this.passthrough(\"http://api.acme.com/**\") },}) 通过这种方法，可以专注的开发和测试新功能而不用担心因为旧接口的存在而不能 Mock。 本章节的内容已经足够在你的项目中使用 Mirage 了。下一章节来详细说说 Mirage 中的一些主要概念。","link":"/Notes/Mirage-JS/miragejs-quickstarts-part-1-overview/"}],"tags":[{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"environment","slug":"environment","link":"/tags/environment/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue-element-admin","slug":"vue-element-admin","link":"/tags/vue-element-admin/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"python3","slug":"python3","link":"/tags/python3/"},{"name":"moviepy","slug":"moviepy","link":"/tags/moviepy/"},{"name":"librosa","slug":"librosa","link":"/tags/librosa/"},{"name":"video","slug":"video","link":"/tags/video/"},{"name":"mock","slug":"mock","link":"/tags/mock/"},{"name":"API Mock","slug":"API-Mock","link":"/tags/API-Mock/"},{"name":"MirageJS","slug":"MirageJS","link":"/tags/MirageJS/"},{"name":"mirage","slug":"mirage","link":"/tags/mirage/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Python","slug":"Technology/Python","link":"/categories/Technology/Python/"},{"name":"Javascript","slug":"Technology/Javascript","link":"/categories/Technology/Javascript/"},{"name":"Mirage-JS","slug":"Notes/Mirage-JS","link":"/categories/Notes/Mirage-JS/"}]}